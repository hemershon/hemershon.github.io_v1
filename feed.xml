<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hemershon Silva</title>
    <description>Engenheiro de software e Ciêntista da computação, intusiasta pelo mundo da tecnologia</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 21 Jan 2023 17:29:17 -0300</pubDate>
    <lastBuildDate>Sat, 21 Jan 2023 17:29:17 -0300</lastBuildDate>
    <generator>Jekyll v3.6.3</generator>
    
      <item>
        <title>Gem para projetos</title>
        <description>&lt;h2 id=&quot;gem-fundamentais-para-um-projeto-rails&quot;&gt;Gem Fundamentais Para Um Projeto Rails&lt;/h2&gt;

&lt;h3 id=&quot;gem-jbuilder&quot;&gt;Gem Jbuilder&lt;/h3&gt;

&lt;p&gt;O Jbuilder oferece uma DSL simples para declarar estruturas JSON que superam a manipulação de estruturas hash gigantes. Isso é particularmente útil quando o processo de geração está repleto de condicionais e loops. Aqui está um exemplo simples:&lt;/p&gt;

&lt;h3 id=&quot;gem-rack-cors&quot;&gt;Gem rack-cors&lt;/h3&gt;

&lt;p&gt;Rack::Cors fornece suporte para Cross-Origin Resource Sharing (CORS) para aplicativos da web compatíveis com Rack.
A especificação CORS permite que aplicativos da web façam chamadas AJAX de domínio cruzado sem usar soluções alternativas como JSONP. Consulte Ajax entre domínios com compartilhamento de recursos entre origens&lt;/p&gt;
&lt;h3 id=&quot;gem-dry-configurable&quot;&gt;Gem dry-configurable&lt;/h3&gt;

&lt;p&gt;dry-configurableé um mixin simples para adicionar comportamento de configuração seguro com thread às suas classes. Existem muitas bibliotecas que fazem uso de configuração, e cada uma parecia ter sua própria implementação com uma interface semelhante ou duplicada, por isso achamos estranho que esse comportamento ainda não tivesse sido encapsulado em uma gema reutilizável, daí dry-configurablenasceu.&lt;/p&gt;
&lt;h3 id=&quot;gem-ransack&quot;&gt;Gem ransack&lt;/h3&gt;

&lt;p&gt;Ransack permite a criação de formulários de pesquisa simples e avançados para seu aplicativo Ruby on Rails ( código-fonte de demonstração aqui ). Se você está procurando por algo que simplifica a geração de consultas no modelo ou na camada do controlador, provavelmente não está procurando pelo Ransack (ou MetaSearch, nesse caso). Em vez disso, tente Squeel .&lt;/p&gt;

&lt;h3 id=&quot;gem-faraday&quot;&gt;Gem faraday&lt;/h3&gt;

&lt;p&gt;Faraday é uma biblioteca cliente HTTP que fornece uma interface comum sobre muitos adaptadores (como Net :: HTTP) e adota o conceito de middleware Rack ao processar o ciclo de solicitação / resposta.&lt;/p&gt;

&lt;h3 id=&quot;gem-rspec_api_documentation&quot;&gt;Gem rspec_api_documentation&lt;/h3&gt;

&lt;p&gt;Generate pretty API docs for your Rails APIs&lt;/p&gt;

&lt;h3 id=&quot;gem-apitome&quot;&gt;Gem apitome&lt;/h3&gt;

&lt;p&gt;Apitome é uma ferramenta de documentação API para Rails construída sobre o excelente RSpec DSL incluído em rspec_api_documentation (RAD). Ele foi projetado para exibir a documentação gerada pelo RAD em uma única página ou em páginas individuais e usa Bootstrap para a maior parte do estilo básico e o highlight.js para realçar o código. Você pode fornecer um arquivo markdown que será exibido como a página README e, aproveitando a vantagem de sua estrutura de visualização modular, você pode substituir qualquer número de visualizações e parciais para personalizar a saída. Você também pode especificar CSS e javascript personalizados se quiser fazer coisas mais sofisticadas ou alterar sua aparência.&lt;/p&gt;

&lt;h3 id=&quot;gem-jwt&quot;&gt;Gem jwt&lt;/h3&gt;

&lt;p&gt;A ruby implementation of the RFC 7519 OAuth JSON Web Token (JWT) standard.
If you have further questions related to development or usage, join us: ruby-jwt google group.&lt;/p&gt;

&lt;h3 id=&quot;gem-devise_invitable&quot;&gt;Gem devise_invitable&lt;/h3&gt;
&lt;p&gt;Adiciona suporte ao Devise para envio de convites por e-mail (requer autenticação) e aceita o convite configurando a senha.&lt;/p&gt;

&lt;h3 id=&quot;gem-devise-token-auth&quot;&gt;Gem devise token auth&lt;/h3&gt;

&lt;p&gt;Autenticação simples, multi-cliente e segura baseada em tokens para Rails.
Se você estiver criando um SPA ou um aplicativo móvel e quiser autenticação, precisará de tokens, não de cookies. Esta gema atualiza os tokens em cada solicitação e os expira em um curto período de tempo, para que o aplicativo esteja seguro. Além disso, ele mantém uma sessão para cada cliente / dispositivo, para que você possa ter quantas sessões quiser.&lt;/p&gt;

&lt;h3 id=&quot;gem-sentry-ruby&quot;&gt;Gem sentry-ruby&lt;/h3&gt;

&lt;p&gt;O software ruim está em toda parte, e estamos cansados ​​disso. O Sentry tem a missão de ajudar os desenvolvedores a escrever software melhor com mais rapidez, para que possamos voltar a aproveitar a tecnologia. Se você quiser se juntar a nósCheck out our open positions&lt;/p&gt;

&lt;h3 id=&quot;gem-sentry-rails&quot;&gt;Gem sentry-rails&lt;/h3&gt;
&lt;p&gt;O SDK Ruby do Sentry permite que os usuários relatem mensagens, exceções e eventos de rastreamento.
O SDK suporta Ruby 2.4+ e as versões mais recentes do JRuby. Ele também se integra a estruturas e bibliotecas populares por meio de gemas específicas da biblioteca.&lt;/p&gt;

&lt;h3 id=&quot;gem-redis&quot;&gt;Gem redis&lt;/h3&gt;
&lt;p&gt;Um cliente Ruby que tenta corresponder à API do Redis um a um, ao mesmo tempo que fornece uma interface idiomática.
Veja RubyDoc.info para a documentação da API da última gem publicada.&lt;/p&gt;

&lt;h3 id=&quot;gem-groupdate&quot;&gt;Gem groupdate&lt;/h3&gt;
&lt;p&gt;A maneira mais simples de agrupar por:
Dia, semana, hora do dia, e mais (lista completa abaixo)
Fusos horários - incluindo horário de verão - com suporte !! a melhor parte
Obtenha a série inteira - a outra melhor parte
Suporta PostgreSQL, MySQL e Redshift, além de matrizes e hashes (e suporte limitado para SQLite )
Anda de mãos dadas com o Chartkick&lt;/p&gt;

&lt;h1 id=&quot;desenvolvimento&quot;&gt;Desenvolvimento&lt;/h1&gt;

&lt;h3 id=&quot;gem-rspec-rails&quot;&gt;Gem rspec-rails&lt;/h3&gt;

&lt;p&gt;rspec-railstraz a estrutura de teste RSpec para Ruby on Rails como uma alternativa drop-in para sua estrutura de teste padrão, Minitest.
No RSpec, os testes não são apenas scripts que verificam o código do seu aplicativo. Eles também são especificações (ou especificações, para abreviar): explicações detalhadas de como o aplicativo deve se comportar, expressas em inglês simples.
De acordo com o uso da nova estratégia de versão do RSpec Rails :&lt;/p&gt;

&lt;h3 id=&quot;gem-shoulda&quot;&gt;Gem shoulda&lt;/h3&gt;
&lt;p&gt;O Shoulda ajuda você a escrever testes específicos de Rails mais compreensíveis e fáceis de manter em Minitest e Test :: Unit.&lt;/p&gt;

&lt;h3 id=&quot;gem-shoulda-matchers&quot;&gt;Gem shoulda-matchers&lt;/h3&gt;

&lt;p&gt;O Shoulda Matchers fornece uma linha compatível com RSpec e Minitest para testar a funcionalidade Rails comum que, se escrita à mão, seria muito mais longa, mais complexa e sujeita a erros.&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Jan 2023 14:24:17 -0300</pubDate>
        <link>/gem-para-projetos</link>
        <guid isPermaLink="true">/gem-para-projetos</guid>
        
        
        <category>Rails</category>
        
      </item>
    
      <item>
        <title>O Básico de Ruby</title>
        <description>&lt;p&gt;Continuando com a saga de &lt;em&gt;como se tornar um programador&lt;/em&gt;, agora vou falar sobre o básico da linguagem ruby, não irei contar a história de ruby e nem como instalar, vou adicionar links que vai ajudar você a lê e instalar.&lt;/p&gt;

&lt;p&gt;Vamos entender primeiro o que é o básico do Ruby, o básico é o que serve como base, essencial e relevante e principalmente fundamental para sua carreira, entendido isso, não tenha dúvida que esse estudo é obrigatório para entender como funciona a linguagem.&lt;/p&gt;

&lt;h2 id=&quot;tipos-de-dados&quot;&gt;Tipos de dados&lt;/h2&gt;

&lt;p&gt;No ruby não existem tipos primitivos, todos os tipos são classes&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Object é a classe mãe de todas as outras classes em Ruby&lt;/li&gt;
  &lt;li&gt;Numeric é uma classe abstrata que representa números&lt;/li&gt;
  &lt;li&gt;Integer é uma classe que representa números inteiros&lt;/li&gt;
  &lt;li&gt;Fixnum representa números inteiros de precisão fixa&lt;/li&gt;
  &lt;li&gt;Bignum representa números inteiros de precisão infinita, dependente apenas da memória disponível&lt;/li&gt;
  &lt;li&gt;Float é uma classe que representa números de ponto flutuante(números reais)&lt;/li&gt;
  &lt;li&gt;String uma cadeia de caracteres. Pode ser delimitado por apóstrofes(‘)ou aspas(“). Tudo o que há entre apóstrofes literalmente, entres aspas o programador deve utilizar de símbolos para representar caracteres específicos, como C. Exemplo: ‘azul’, “a\nb\nc\”&lt;/li&gt;
  &lt;li&gt;Symbol é semelhante a uma string, mas dois símbolos iguais possuem o mesmo endereço de memória, sendo assim é ótimo para se utilizar como índice numa Hash. Porém, devido à sua natureza, o coletor de lixo de ruby não os elimina. É definido com um sinal de dois pontos (:), por exemplo, :none&lt;/li&gt;
  &lt;li&gt;Array são arrays dinâmicos, que podem ser usados para representar matrizes e vetores. É delimitado por colchetes([]) e cada valor é separado por vírgula. Exemplo: [4, ‘azul’, :termometro]&lt;/li&gt;
  &lt;li&gt;Hash representa um vetor associativo, e, assim como as Arrays, é dinâmica. É delimitada por chaves ({}), e o índice precede o valor com um sinal ‘=&amp;gt;’. Exemplo: {:controller =&amp;gt;’user’, :action = ‘index’}.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Qualquer objeto pode ser índice, mas os mais usados são as Strings e os Symbols&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Regex representa expressões regulares, delimitadas por //.
  Funciona de forma semelhante a Perl. Exemplo: 
  /a|ae/&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Esses são os tipos de dados usados na linguagem desde o início.&lt;/p&gt;

&lt;p&gt;Entenda isso e você vai entender a linguagem.&lt;/p&gt;

&lt;p&gt;Um dos conceitos básicos da linguagem é a declaração das variáveis, que basta uma associação entre um nome e um valor que é pronto é criada uma variável.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Ano = 37
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para você testar, vamos usar o interpretador do ruby que é o IRB(Interactive Ruby Shell).
Vá no seu terminal e digite irb, veja que ele vai abrir&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;╰─ irb                       
2.6.6 :001 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Um console que abre informando a versão do seu ruby e o número de vezes que ele foi usado.&lt;/p&gt;

&lt;p&gt;No primeiro exemplo declaramos uma variável do tipo inteiro que ela vai ser chamada de ano e atribuímos o valor 37 nela, mais como o interpretador sabe que ali tem uma variável do tipo inteiro.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ano = 37
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ruby tem um intérpretador que infere o tipo de variável durante a execução do código.&lt;/p&gt;

&lt;p&gt;Uma forma interessante para você identificar o tipo da variável&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ano = 37 
puts ano.class
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Você pediu para o puts mostrar o tipo da variável ano.
 Que o resultado vai ser :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;╰─ irb                          
2.6.6 :001 &amp;gt; 2.6.6 :001 &amp;gt; ano = 37 
 =&amp;gt; 37 
2.6.6 :002 &amp;gt; puts ano.class
Integer
 =&amp;gt; nil 
2.6.6 :003 &amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando chamamos o &lt;strong&gt;.class&lt;/strong&gt; depois de qualquer variável ele trás o tipo de variável.&lt;/p&gt;

&lt;h2 id=&quot;tipagem&quot;&gt;Tipagem&lt;/h2&gt;

&lt;p&gt;Qual é a diferença entre tipagens;&lt;/p&gt;

&lt;h3 id=&quot;estática&quot;&gt;Estática&lt;/h3&gt;

&lt;p&gt;Tipagem estática é quando definimos explicitamente o tipo de variáveis de um software no código que na hora da compilação do código ele é conhecido e checado.&lt;/p&gt;

&lt;p&gt;Linguagem que usam tipagem estáticas 
Java, C#, F#, Kotlin, Go.&lt;/p&gt;

&lt;p&gt;Essa análise ajuda na chamada de segurança de tipos na utilização dos dados pelo programador.&lt;/p&gt;

&lt;h3 id=&quot;dinâmica&quot;&gt;Dinâmica&lt;/h3&gt;

&lt;p&gt;A tipagem dinâmica também é verificada mais de uma maneira diferente, ela verifica direto os tipos de dados.&lt;/p&gt;

&lt;p&gt;Linguagem que usam tipagens dinâmicas
Ruby, Python, Clojure, Elixir.&lt;/p&gt;

&lt;h3 id=&quot;forte&quot;&gt;Forte&lt;/h3&gt;
&lt;p&gt;A tipagem forte não realiza conversões automaticamente.&lt;/p&gt;

&lt;h3 id=&quot;fraca&quot;&gt;Fraca&lt;/h3&gt;

&lt;p&gt;A tipagem fraca, vem da característica da linguagem de realizar conversões automaticamente entre diferentes tipos de dados.&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Jan 2023 13:57:32 -0300</pubDate>
        <link>/o-basico-de-ruby</link>
        <guid isPermaLink="true">/o-basico-de-ruby</guid>
        
        
        <category>Ruby</category>
        
      </item>
    
      <item>
        <title>MÉTODOS PARA TRATAR ARRAY</title>
        <description>&lt;p&gt;Recentemente me deparei em uma situação interessante, qual é o momento em que devemos usar &lt;strong&gt;map&lt;/strong&gt;, &lt;strong&gt;select&lt;/strong&gt; e o &lt;strong&gt;each&lt;/strong&gt;, normalmente eu uso o &lt;strong&gt;each&lt;/strong&gt; com frequência aí veio a dúvida em qual momento devemos usar os outros métodos e qual é a diferença entre eles?&lt;/p&gt;

&lt;p&gt;Dica: antes de procura em toda parte da web vá primeiro na documentação leia se não entendeu procure contexto diferentes de explicação, por que é importante você saber usar a documentação. Procurando na documentação você se depara com a seguinte situação;&lt;/p&gt;

&lt;h2 id=&quot;map&quot;&gt;MAP&lt;/h2&gt;

&lt;p&gt;O &lt;strong&gt;map&lt;/strong&gt; invoca o bloco fornecido uma vez para cada elemento de self. Criando um novo array contendo os valores retornados pelo bloco, se caso nenhum bloco for fornecido, um Enumerador será retornado&lt;/p&gt;

&lt;h4 id=&quot;detalhes-do-map&quot;&gt;Detalhes do &lt;strong&gt;map&lt;/strong&gt;:&lt;/h4&gt;
&lt;p&gt;O podemos usar ele com &lt;strong&gt;&lt;em&gt;arrays&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;hashes&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;ranges&lt;/em&gt;&lt;/strong&gt; o principal uso do &lt;strong&gt;&lt;em&gt;map&lt;/em&gt;&lt;/strong&gt; é transformar dados.&lt;/p&gt;

&lt;h4 id=&quot;por-exemplo&quot;&gt;por exemplo:&lt;/h4&gt;
&lt;p&gt;Dada uma matriz de strings, você pode passar por cima de cada string e tornar cada caractere maiúsculo&lt;/p&gt;

&lt;h4 id=&quot;sintaxe-do-map-no-ruby&quot;&gt;Sintaxe do map no Ruby&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
array.map { |string| string.upcase } # [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;collect&quot;&gt;Collect&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;collect&lt;/strong&gt; invoca o bloco fornecido uma vez para cada elemento de self, ele criar um novo array contendo os valores retornados pelo bloco, se não estiver nenhum bloco ele será retornado um Enumerador, no caso é a mesma coisa que o map.&lt;/p&gt;

&lt;h4 id=&quot;detalhes-do-collect&quot;&gt;Detalhes do collect&lt;/h4&gt;

&lt;p&gt;O collect() de enumerable é um método embutido em ruby que retorna um novo array com resultados da execução do bloco uma vez para cada elemento em enum O objeto é repetido todas as veses para cada enum, caso nenhum objeto seja fornecido, ele retorna nil para cada enum&lt;/p&gt;

&lt;h3 id=&quot;sintaxe&quot;&gt;Sintaxe:&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; (r1..r2).collect {|obj| bloquado }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parâmetros: A função pega o objeto e o bloco que é para cada enum, também leva r1 e r2 que decide o número de elementos no enumerável retornado.&lt;/p&gt;

&lt;p&gt;valor do retorno: Retorna um novo array&lt;/p&gt;

&lt;p&gt;retorna o enumerador&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;enu = (2..6).collect { |x| x * 10 } # [20, 30, 40, 50, 60]
retorna o valor nil

enu = (2..6).collect {} # [nil, nil, nil, nil, nil]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;fonte-geeksforgeeks&quot;&gt;fonte: Geeksforgeeks&lt;/h5&gt;
&lt;h2 id=&quot;select&quot;&gt;Select&lt;/h2&gt;

&lt;p&gt;O &lt;strong&gt;select&lt;/strong&gt; funciona de duas maneiras únicas; Primeiro: pega o bloco para que possa ser usado como array#select Segundo: Modifica a instrução SELECT da consulta para que apenas determinados campos sejam recuperados.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;[1, 2, 3, 4, 5].select { |num| num.event? } # [2, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Exemplo 2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;a = %w{ a b c d e f }
a.select { |v| v =~ /[aeiou]/ } # [&quot;a&quot;, &quot;e&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;detalhes-do-select&quot;&gt;Detalhes do select&lt;/h4&gt;

&lt;p&gt;Select é um método de calsse array que retorna um novo array contendo todos os elementos do array para os quais o bloco dado retorna um valor verdadeiro.&lt;/p&gt;

&lt;p&gt;Sintaxe: array.select()&lt;/p&gt;

&lt;p&gt;Parâmentro: Matriz&lt;/p&gt;

&lt;p&gt;Retorno: Uma nova matriz contendo todos os elemetos da matriz para os quais o bloco fornecido retorna um valor verdadeiro.&lt;/p&gt;

&lt;h5 id=&quot;fonte-geeksforgeeks-1&quot;&gt;fonte: Geeksforgeeks&lt;/h5&gt;

&lt;p&gt;O each chama o bloco fornecido uma vez para cada elemento em self, passando esse elemento como um parâmetro, no caso ele retornar o próprio array, se caso nenhum bloco for fornecedor ele também traz um Enumerador.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 a.each { |x| print x, &quot;--&quot; } # a--b--c-- =&amp;gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Isso foi um resumo para entender melhor como tratar seus array usando métodos diferentes para situações diferentes.&lt;/p&gt;

&lt;h5 id=&quot;fontes-apidock&quot;&gt;Fontes: Apidock&lt;/h5&gt;
</description>
        <pubDate>Fri, 20 Jan 2023 12:33:12 -0300</pubDate>
        <link>/metodos-para-tratar-array</link>
        <guid isPermaLink="true">/metodos-para-tratar-array</guid>
        
        <category>rails</category>
        
        <category>ruby</category>
        
        <category>linux</category>
        
        <category>metodos</category>
        
        
        <category>Rails</category>
        
        <category>Ruby</category>
        
        <category>Code</category>
        
      </item>
    
  </channel>
</rss>
