<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hemershon Silva</title>
    <description>Engenheiro de software e Ciêntista da computação, intusiasta pelo mundo da tecnologia</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 04 May 2023 14:58:03 -0300</pubDate>
    <lastBuildDate>Thu, 04 May 2023 14:58:03 -0300</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>Um olhar simples para a buscar Linear</title>
        <description>&lt;p&gt;O algoritmo de busca linear é muito simples e intuitivo. A ideia é percorrer todos os elementos do array um por um, verificando se cada elemento é igual ao valor de destino que estamos procurando. Se encontrarmos o elemento que estamos procurando, retornamos o índice do elemento no array. Se não encontrarmos o elemento, retornamos nil para indicar que o valor não foi encontrado.&lt;/p&gt;

&lt;p&gt;Na implementação em Ruby, a função linear_search recebe dois argumentos: o array a ser pesquisado e o valor de destino que estamos procurando. Em seguida, a função usa um laço each_with_index para iterar por todos os elementos do array. A cada iteração, o laço passa o elemento atual e o índice desse elemento para um bloco que usa as variáveis item e index.&lt;/p&gt;

&lt;p&gt;Dentro do bloco, verificamos se o elemento atual é igual ao valor de destino que estamos procurando. Se o elemento atual for igual ao valor de destino, retornamos o índice do elemento usando a palavra-chave return. Isso significa que a função termina imediatamente e não executa nenhuma iteração adicional do laço.&lt;/p&gt;

&lt;p&gt;Se chegarmos ao final do laço sem encontrar o valor de destino, isso significa que o valor não está presente no array e a função retorna nil.&lt;/p&gt;

&lt;p&gt;Aqui está um exemplo de como usar a função linear_search para procurar o valor 42 no array [1, 2, 3, 4, 5, 42, 43, 44]:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def linear_search(array, target)
  array.each_with_index do |item, index|
    if item == target
      return index
    end
  end

  return nil 
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array = [2, 3, 4, 9, 19, 20]
target = 20

index = linear_search(array, target)
 if index 
  puts &quot;O valor #{target} foi encontrado no índece #{index} do array&quot;
 else
  puts &quot;O valor #{target} não foi encontrado no array&quot;
 end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Neste exemplo, a função linear_search é usada para procurar o valor 42 no array. A função retorna o índice 5, que é o índice do valor 42 no array. Em seguida, uma mensagem é exibida informando que o valor foi encontrado no índice 5 do array.&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Apr 2023 13:22:55 -0300</pubDate>
        <link>/um-olhar-simples-para-a-buscar-linear</link>
        <guid isPermaLink="true">/um-olhar-simples-para-a-buscar-linear</guid>
        
        <category>ruby</category>
        
        <category>linux</category>
        
        <category>algoritmo</category>
        
        
        <category>Ruby</category>
        
        <category>Code</category>
        
        <category>algoritmo</category>
        
      </item>
    
      <item>
        <title>Sintaxe Ruby</title>
        <description>&lt;p&gt;A sintaxe Ruby é baseada em uma estrutura simples de comandos, métodos e expressões. A seguir, são apresentados alguns exemplos da sintaxe Ruby:&lt;/p&gt;

&lt;p&gt;Declaração de variáveis:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nome = &quot;Maria&quot;
idade = 25
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Estruturas de controle:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if idade &amp;gt;= 18
  puts &quot;Você é maior de idade&quot;
else
  puts &quot;Você é menor de idade&quot;
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Laços de repetição:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i in 1..10
  puts i
end

10.times do |i|
  puts i
end
Definindo funções:
css
Copy code
def somar(a, b)
  return a + b
end

resultado = somar(2, 3)
puts resultado
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Trabalhando com arrays:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;numeros = [1, 2, 3, 4, 5]
numeros.each do |numero|
  puts numero
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Trabalhando com strings:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nome = &quot;Maria&quot;
mensagem = &quot;Olá, #{nome}!&quot;
puts mensagem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Trabalhando com classes:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Pessoa
  def initialize(nome, idade)
    @nome = nome
    @idade = idade
  end
  
  def apresentar
    puts &quot;Meu nome é #{@nome} e tenho #{@idade} anos&quot;
  end
end

pessoa = Pessoa.new(&quot;Maria&quot;, 25)
pessoa.apresentar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Esses são apenas alguns exemplos da sintaxe Ruby. A linguagem também oferece muitas outras ferramentas e recursos, como metaprogramação, expressões regulares, manipulação de arquivos e muito mais.&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Mar 2023 13:49:00 -0300</pubDate>
        <link>/sintaxe-ruby</link>
        <guid isPermaLink="true">/sintaxe-ruby</guid>
        
        
      </item>
    
      <item>
        <title>O QUE VOCÊ PRECISA SABER SOBRE RUBY</title>
        <description>&lt;p&gt;Aqui estão alguns tópicos interessantes sobre a linguagem Ruby:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ruby é uma linguagem de programação orientada a objetos, o que significa que todos os objetos em Ruby têm métodos e propriedades. Isso torna a linguagem muito flexível e permite que os desenvolvedores escrevam código mais legível e fácil de entender.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A sintaxe de Ruby é muito limpa e elegante, o que torna a linguagem fácil de ler e escrever. Além disso, a linguagem suporta muitas construções de programação funcionais e inspiradas em linguagens como Lisp e Smalltalk.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ruby é uma linguagem que suporta metaprogramação, o que significa que os desenvolvedores podem escrever código que pode modificar outros códigos em tempo de execução. Isso permite a criação de bibliotecas e frameworks poderosos, como o Rails.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ruby tem uma biblioteca padrão muito rica, o que significa que há muitas ferramentas e recursos disponíveis para os desenvolvedores usarem sem ter que instalar bibliotecas adicionais. Isso economiza tempo e torna a linguagem mais acessível para iniciantes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Embora Ruby seja uma linguagem orientada a objetos, ela também suporta programação funcional. Isso permite que os desenvolvedores escrevam código mais conciso e legível, especialmente em tarefas que envolvem transformações de dados.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ruby on Rails é um framework popular para a criação de aplicativos web. É conhecido por sua simplicidade e facilidade de uso, bem como sua capacidade de criar aplicativos robustos e escaláveis em um curto período de tempo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A comunidade Ruby é grande e ativa, com muitos recursos disponíveis para ajudar os desenvolvedores a aprender e usar a linguagem. Há também muitos eventos e conferências de Ruby em todo o mundo.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 31 Mar 2023 12:20:40 -0300</pubDate>
        <link>/o-que-voce-precisa-saber-sobre-ruby</link>
        <guid isPermaLink="true">/o-que-voce-precisa-saber-sobre-ruby</guid>
        
        <category>rails</category>
        
        <category>ruby</category>
        
        <category>linux</category>
        
        <category>metodos</category>
        
        
        <category>Rails</category>
        
        <category>Ruby</category>
        
        <category>Code</category>
        
      </item>
    
      <item>
        <title>Problemas encontrado para estudar programação</title>
        <description>&lt;p&gt;Quais são os problemas mais frequentes quando resolvemos estudar programação?&lt;/p&gt;

&lt;p&gt;Vou relatar alguns problemas que passei durante minha vida de estudante da programação, esse post faz parte de como eu estudei errado.&lt;/p&gt;

&lt;p&gt;Quando comecei não tinha toda essa estrutura que temos hoje de google, stack overflow, e outros.&lt;/p&gt;

&lt;p&gt;A primeira dúvida era o que estudar, como começa?&lt;/p&gt;

&lt;p&gt;Tutorial de html e css
Procurei na internet alguns tutoriais que ensinava a criar sites, daí fui logo pro fogo sem saber de nada sem entender o que é html e sem entender qual era o impacto do css dentro de um site, então veio as primeiras caneladas como não sabia o que estava fazendo eu ia fazendo de qualquer jeito esperando resultados iguais do tutoriais.&lt;/p&gt;

&lt;p&gt;Dicas: 
antes de ir para o fogo, estude o básico, não saia dele antes de entender como o ecossistema funciona, não importa se é uma linguagem simples. 
Procure alguém para pegar referência, alguém mais experiente vai te dar dicas importantes.
Crie uma rotina de estudos com foco e disciplina.
Estudar o que está no Hype?
Fiquei meio perdido quando comecei, por não ter uma direção, eu estudava tudo que aparecia, então não aprendia nada.&lt;/p&gt;

&lt;p&gt;Dicas:
Separe um material, curso ou livro ou post de blog, estude, entenda e depois vá para o próximo.
Tenha disciplina ao estudar esse material, separe um horário para aquela rotina de estudos, no começo é difícil mas com foco e disciplina você consegue.&lt;/p&gt;

&lt;p&gt;Organização?
Como relatado acima, estava perdido e não tinha um pingo de organização, 
Não sabia o que estudava e nem sabia organizar meus estudos e meus materiais então quando pulava para outro tutorial ou livro ou curso, quase sempre me via estudando o mesmo conteúdo.&lt;/p&gt;

&lt;p&gt;Dicas:
Quando você separar o material, faça um cronograma do que você vai estudar, se for por meio de vídeos, primeiro assista e anote pontos importantes depois execute, não entendeu o processo, reveja o vídeo novamente, na sua cabeça rever o vídeo vai deixar você pra trás, acredite isso vai ajudar você lá na frente.
Dúvidas?
É natural quando você está estudando ter dúvidas relacionadas ao conteúdo, quando estava com dúvidas simplesmente não tinha com quem tirar, então pulava para a próxima parte do conteúdo, pois achava que tinha uma explicação no próximo capítulo ou vídeo.&lt;/p&gt;

&lt;p&gt;Dicas:
Procure um mentor, alguém que possa tirar suas dúvidas e orientar seu processo de aprendizagem.&lt;/p&gt;

&lt;p&gt;Faça perguntas inteligentes.
Confesso que hoje está mais fácil tirar dúvidas, stack overflow, google, comunidades e outros.
Peguei algumas patadas no começo de algumas pessoas, por simplesmente não saber perguntar para ela, ou o problema era simples e não tinha lido direito, e não tinha sequer pesquisado algo antes para ver se conseguia resolver.&lt;/p&gt;

&lt;p&gt;Dicas:
Se você sentir que precisar de uma abordagem “one to one”, faça o seguinte;
Pesquise antes no google, o problema que você está passando hoje já foi problema de alguém no passado.
Não conseguiu entender ou não conseguiu achar, elabore sua pergunta e deixe ela o mais claro possível e deixe visível para a pessoa a parte que você não entendeu.
Na abordagem, lembra que a pessoa que você irá pedir ajuda tem compromisso, então não faça ela perder tempo.
Seja direto e claro.&lt;/p&gt;

&lt;p&gt;Esse post foi para dar dicas para melhorar seu desempenho nos estudos da programação.
Espero ter ajudado com esse conteúdo.&lt;/p&gt;

</description>
        <pubDate>Sat, 21 Jan 2023 14:39:02 -0300</pubDate>
        <link>/problemas-encontrado-para-estudar-programacao</link>
        <guid isPermaLink="true">/problemas-encontrado-para-estudar-programacao</guid>
        
        <category>rails</category>
        
        <category>ruby</category>
        
        <category>linux</category>
        
        <category>metodos</category>
        
        
        <category>Rails</category>
        
        <category>Ruby</category>
        
        <category>Code</category>
        
      </item>
    
      <item>
        <title>Estudando Programação</title>
        <description>&lt;p&gt;Estudando Programação&lt;/p&gt;

&lt;p&gt;Como identifiquei que sempre estudei errado.&lt;/p&gt;

&lt;p&gt;Mais uma história dessa saga de se tornar um programador.
Quando comecei na programação há alguns anos atrás, fiquei muito perdido, como assim tem um caminho a seguir, lógica de programação, depois… ai que está o depois que é o obstáculo.
Você não sabe o que estudar, o que é relevante para sua carreira, por isso que muitos iniciantes desistem ou até mesmo demoram a encontrar o caminho relevante.
Imagina um iniciante estudando tudo pela frente ou pior, seguindo um passo a passo sem entender muito bem o que é o que faz e quais problemas você consegue resolver com a ferramenta.
Então essa era minha rotina diária de estudos, depois de um certo tempo conversando com meu irmão ele me mostrou uma tecnologia nova gostei dela e fui estudar-lá.
Só que tinha um problema, eu não tinha autogestão, então como ia estudar sem os controles principais foco e persistência, foi assim que fiquei por anos sem entender direito sobre o assunto, aí me tornei um programador mediano, não sabia usar a ferramenta direito e não conhecia todo o poder que a ferramenta tinha, nisso ficava bastante frustrado em minha capacidade técnica, passei por algumas empresas que pioraram minha frustração, e tinha o lado que não conseguia identificar meus erros, sempre me dedicando bastante para melhorar, depois do trabalho eu estudava bastante  e nada de evoluir. 
Fui entrando e saindo das empresas com a mesma frustração de não conseguir entregar algo de valor para empresa. 
Na minha saga de melhorar como programador, fui para em uma entrevista com tech lead Marco, que isso é assunto para outro post.
Foi aí que descobri que meus estudos estavam errados, não tinha base lógica, nem soft skill e nem hard skill, fui descobrindo isso quando comecei a acompanhar sua mentoria, nela descobri que um programador precisa ter uma caixa de ferramenta para melhorar como profissional, depois de muito tempo que fui entender o verdadeiro caminho das pedras.&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Jan 2023 14:33:52 -0300</pubDate>
        <link>/estudando-programacao</link>
        <guid isPermaLink="true">/estudando-programacao</guid>
        
        <category>rails</category>
        
        <category>ruby</category>
        
        <category>linux</category>
        
        <category>metodos</category>
        
        
        <category>Rails</category>
        
        <category>Ruby</category>
        
        <category>Code</category>
        
      </item>
    
      <item>
        <title>Descobrindo o caminho das pedras</title>
        <description>&lt;p&gt;Continuando com a história de como sempre estudei errado, essa parte vou falar como melhorei meus estudos e desempenho na programação, como falei no post anterior comecei a melhorar depois da mentoria do DesenvolvendoMe.&lt;/p&gt;

&lt;p&gt;Lá aprendi a usar novas técnicas de desenvolvimento de software, e o que é preciso para melhorar como programador.&lt;/p&gt;

&lt;p&gt;Estudando de maneira correta.&lt;/p&gt;

&lt;p&gt;vamos dizer que você está empolgado com a área de TI, são várias linguagem, vários framework, vários influenciadores, aí você começa a estudar uma tecnologia que está no hype do mercado e algumas pessoas estão comentando sobre ela, você passa uma semana ou mais estudando ela sem entender direito o que está fazendo, aí você vê o lançamento de um framework, você pensar deve ser mais fácil aprender esse framework, e você vai e muda e começa a estudar só que sem entender nada.&lt;/p&gt;

&lt;p&gt;Chega uma hora que você se pergunta porque não estou entendendo e não consigo aprender.&lt;/p&gt;

&lt;p&gt;Sabe porque sua lógica pode está com falhas, mais você leu em algum lugar que não precisa de lógica de programação para aprender a programar, eu sempre penso assim, pra você fritar um ovo você precisa entender o processo e seguir passo a passo, até deixar o ovo pronto, na  programação não é diferente, você vai precisar entender o processo, regras de negócios e entender sobre o próprio negócio, a lógica vai facilitar pra você esse processo.&lt;/p&gt;

&lt;p&gt;O que você precisar para fixar o estudos&lt;/p&gt;

&lt;p&gt;além de estudar o básico da linguagem, aconselho a você ir nesses sites de teste lógicos para que você comece a exercitar formas de resolver um problema, como Uri, Hackerrank, esses sites ajuda bastante, eles disponibilizar exercícios básicos ao avançado para todo os níveis, vale a pena separar uma hora diária para praticar.&lt;/p&gt;

&lt;p&gt;Aconselho a separar 30 minutos diários para praticar o básico da linguagem.&lt;/p&gt;

&lt;p&gt;E o mais importante, leia a documentação, é ali que você vai entender tudo da linguagem.&lt;/p&gt;

&lt;p&gt;Planejar um projeto e executar ele também vai ajudar na evolução.&lt;/p&gt;

&lt;p&gt;Bom essa foi  a parte do Hard Skill, só entenda o seguinte, aprender requer determinação e foco sem isso você vai continuar rodando em círculo, use um pomodoro para ajudar no foco, determine um tempo que você achar melhor para praticar o foco, geralmente uso uma hora focado sem distrações.&lt;/p&gt;

&lt;p&gt;Agora tem a parte do soft skill.&lt;/p&gt;

&lt;p&gt;Soft skill é a arte de saber perguntar, quando você está começando no mundo da programação, você tem que perguntar muito, poder parece engraçado, mas na realidade você não entender como aquilo vai funcionar não fique com vergonha mesmo sabendo que a pessoa que vai te explicar é grossa e arrogante.&lt;/p&gt;

&lt;p&gt;Tinha um conhecido que ele era uma pessoa muito arrogante, toda vez que eu ia perguntar uma coisa simples ele me respondia com grosseria mais respondia, mais não seja um petelho, aprender fazer perguntas inteligentes, mais como assim perguntas inteligentes, antes de perguntar para outra pessoa vá no google que lá vai ter alguma coisa explicando de uma forma que você possivelmente não entender de cara, então anote os pontos principais e o que você não entendeu e tenta resumir de uma forma objetiva para que a pessoa que vai ouvir ou ler sua pergunta entenda, porque eu falo isso, porque a pessoa vai parar o que ela está fazendo para te ajudar, então mastiga o máximo que você puder para facilitar a resposta ou até mesmo irem juntos procurar uma solução.&lt;/p&gt;

&lt;p&gt;Nas suas conversas aprender a ser objetivo, fazer rodeio mesmo sabendo o que está falando pode ser cansativo para quem está ouvindo, bateu a dúvida anote, geralmente eu anoto tudo no keep do google, depois vou lá e organizo minhas dúvidas e perguntas, antes de fazer a pergunta eu dou uma revisada e tento resumir e se bem objetivo, se caso a pessoa que está ouvindo não entender eu explico de uma forma mais detalhada.&lt;/p&gt;

&lt;p&gt;Tenha sempre foco e determinação, pense assim seus estudos são como uma construção de um prédio, se você não fizer uma estrutura forte na sua base, ele vai sempre balançar.&lt;/p&gt;

</description>
        <pubDate>Sat, 21 Jan 2023 14:30:40 -0300</pubDate>
        <link>/descobrindo-o-caminho-das-pedras</link>
        <guid isPermaLink="true">/descobrindo-o-caminho-das-pedras</guid>
        
        <category>rails</category>
        
        <category>ruby</category>
        
        <category>linux</category>
        
        <category>metodos</category>
        
        
        <category>Rails</category>
        
        <category>Ruby</category>
        
        <category>Code</category>
        
      </item>
    
      <item>
        <title>Gem para projetos</title>
        <description>&lt;h2 id=&quot;gem-fundamentais-para-um-projeto-rails&quot;&gt;Gem Fundamentais Para Um Projeto Rails&lt;/h2&gt;

&lt;h3 id=&quot;gem-jbuilder&quot;&gt;Gem Jbuilder&lt;/h3&gt;

&lt;p&gt;O Jbuilder oferece uma DSL simples para declarar estruturas JSON que superam a manipulação de estruturas hash gigantes. Isso é particularmente útil quando o processo de geração está repleto de condicionais e loops. Aqui está um exemplo simples:&lt;/p&gt;

&lt;h3 id=&quot;gem-rack-cors&quot;&gt;Gem rack-cors&lt;/h3&gt;

&lt;p&gt;Rack::Cors fornece suporte para Cross-Origin Resource Sharing (CORS) para aplicativos da web compatíveis com Rack.
A especificação CORS permite que aplicativos da web façam chamadas AJAX de domínio cruzado sem usar soluções alternativas como JSONP. Consulte Ajax entre domínios com compartilhamento de recursos entre origens&lt;/p&gt;
&lt;h3 id=&quot;gem-dry-configurable&quot;&gt;Gem dry-configurable&lt;/h3&gt;

&lt;p&gt;dry-configurableé um mixin simples para adicionar comportamento de configuração seguro com thread às suas classes. Existem muitas bibliotecas que fazem uso de configuração, e cada uma parecia ter sua própria implementação com uma interface semelhante ou duplicada, por isso achamos estranho que esse comportamento ainda não tivesse sido encapsulado em uma gema reutilizável, daí dry-configurablenasceu.&lt;/p&gt;
&lt;h3 id=&quot;gem-ransack&quot;&gt;Gem ransack&lt;/h3&gt;

&lt;p&gt;Ransack permite a criação de formulários de pesquisa simples e avançados para seu aplicativo Ruby on Rails ( código-fonte de demonstração aqui ). Se você está procurando por algo que simplifica a geração de consultas no modelo ou na camada do controlador, provavelmente não está procurando pelo Ransack (ou MetaSearch, nesse caso). Em vez disso, tente Squeel .&lt;/p&gt;

&lt;h3 id=&quot;gem-faraday&quot;&gt;Gem faraday&lt;/h3&gt;

&lt;p&gt;Faraday é uma biblioteca cliente HTTP que fornece uma interface comum sobre muitos adaptadores (como Net :: HTTP) e adota o conceito de middleware Rack ao processar o ciclo de solicitação / resposta.&lt;/p&gt;

&lt;h3 id=&quot;gem-rspec_api_documentation&quot;&gt;Gem rspec_api_documentation&lt;/h3&gt;

&lt;p&gt;Generate pretty API docs for your Rails APIs&lt;/p&gt;

&lt;h3 id=&quot;gem-apitome&quot;&gt;Gem apitome&lt;/h3&gt;

&lt;p&gt;Apitome é uma ferramenta de documentação API para Rails construída sobre o excelente RSpec DSL incluído em rspec_api_documentation (RAD). Ele foi projetado para exibir a documentação gerada pelo RAD em uma única página ou em páginas individuais e usa Bootstrap para a maior parte do estilo básico e o highlight.js para realçar o código. Você pode fornecer um arquivo markdown que será exibido como a página README e, aproveitando a vantagem de sua estrutura de visualização modular, você pode substituir qualquer número de visualizações e parciais para personalizar a saída. Você também pode especificar CSS e javascript personalizados se quiser fazer coisas mais sofisticadas ou alterar sua aparência.&lt;/p&gt;

&lt;h3 id=&quot;gem-jwt&quot;&gt;Gem jwt&lt;/h3&gt;

&lt;p&gt;A ruby implementation of the RFC 7519 OAuth JSON Web Token (JWT) standard.
If you have further questions related to development or usage, join us: ruby-jwt google group.&lt;/p&gt;

&lt;h3 id=&quot;gem-devise_invitable&quot;&gt;Gem devise_invitable&lt;/h3&gt;
&lt;p&gt;Adiciona suporte ao Devise para envio de convites por e-mail (requer autenticação) e aceita o convite configurando a senha.&lt;/p&gt;

&lt;h3 id=&quot;gem-devise-token-auth&quot;&gt;Gem devise token auth&lt;/h3&gt;

&lt;p&gt;Autenticação simples, multi-cliente e segura baseada em tokens para Rails.
Se você estiver criando um SPA ou um aplicativo móvel e quiser autenticação, precisará de tokens, não de cookies. Esta gema atualiza os tokens em cada solicitação e os expira em um curto período de tempo, para que o aplicativo esteja seguro. Além disso, ele mantém uma sessão para cada cliente / dispositivo, para que você possa ter quantas sessões quiser.&lt;/p&gt;

&lt;h3 id=&quot;gem-sentry-ruby&quot;&gt;Gem sentry-ruby&lt;/h3&gt;

&lt;p&gt;O software ruim está em toda parte, e estamos cansados ​​disso. O Sentry tem a missão de ajudar os desenvolvedores a escrever software melhor com mais rapidez, para que possamos voltar a aproveitar a tecnologia. Se você quiser se juntar a nósCheck out our open positions&lt;/p&gt;

&lt;h3 id=&quot;gem-sentry-rails&quot;&gt;Gem sentry-rails&lt;/h3&gt;
&lt;p&gt;O SDK Ruby do Sentry permite que os usuários relatem mensagens, exceções e eventos de rastreamento.
O SDK suporta Ruby 2.4+ e as versões mais recentes do JRuby. Ele também se integra a estruturas e bibliotecas populares por meio de gemas específicas da biblioteca.&lt;/p&gt;

&lt;h3 id=&quot;gem-redis&quot;&gt;Gem redis&lt;/h3&gt;
&lt;p&gt;Um cliente Ruby que tenta corresponder à API do Redis um a um, ao mesmo tempo que fornece uma interface idiomática.
Veja RubyDoc.info para a documentação da API da última gem publicada.&lt;/p&gt;

&lt;h3 id=&quot;gem-groupdate&quot;&gt;Gem groupdate&lt;/h3&gt;
&lt;p&gt;A maneira mais simples de agrupar por:
Dia, semana, hora do dia, e mais (lista completa abaixo)
Fusos horários - incluindo horário de verão - com suporte !! a melhor parte
Obtenha a série inteira - a outra melhor parte
Suporta PostgreSQL, MySQL e Redshift, além de matrizes e hashes (e suporte limitado para SQLite )
Anda de mãos dadas com o Chartkick&lt;/p&gt;

&lt;h1 id=&quot;desenvolvimento&quot;&gt;Desenvolvimento&lt;/h1&gt;

&lt;h3 id=&quot;gem-rspec-rails&quot;&gt;Gem rspec-rails&lt;/h3&gt;

&lt;p&gt;rspec-railstraz a estrutura de teste RSpec para Ruby on Rails como uma alternativa drop-in para sua estrutura de teste padrão, Minitest.
No RSpec, os testes não são apenas scripts que verificam o código do seu aplicativo. Eles também são especificações (ou especificações, para abreviar): explicações detalhadas de como o aplicativo deve se comportar, expressas em inglês simples.
De acordo com o uso da nova estratégia de versão do RSpec Rails :&lt;/p&gt;

&lt;h3 id=&quot;gem-shoulda&quot;&gt;Gem shoulda&lt;/h3&gt;
&lt;p&gt;O Shoulda ajuda você a escrever testes específicos de Rails mais compreensíveis e fáceis de manter em Minitest e Test :: Unit.&lt;/p&gt;

&lt;h3 id=&quot;gem-shoulda-matchers&quot;&gt;Gem shoulda-matchers&lt;/h3&gt;

&lt;p&gt;O Shoulda Matchers fornece uma linha compatível com RSpec e Minitest para testar a funcionalidade Rails comum que, se escrita à mão, seria muito mais longa, mais complexa e sujeita a erros.&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Jan 2023 14:24:17 -0300</pubDate>
        <link>/gem-para-projetos</link>
        <guid isPermaLink="true">/gem-para-projetos</guid>
        
        <category>rails</category>
        
        <category>ruby</category>
        
        <category>linux</category>
        
        <category>metodos</category>
        
        
        <category>Rails</category>
        
        <category>Ruby</category>
        
        <category>Code</category>
        
      </item>
    
      <item>
        <title>O Básico de Ruby</title>
        <description>&lt;p&gt;Continuando com a saga de &lt;em&gt;como se tornar um programador&lt;/em&gt;, agora vou falar sobre o básico da linguagem ruby, não irei contar a história de ruby e nem como instalar, vou adicionar links que vai ajudar você a lê e instalar.&lt;/p&gt;

&lt;p&gt;Vamos entender primeiro o que é o básico do Ruby, o básico é o que serve como base, essencial e relevante e principalmente fundamental para sua carreira, entendido isso, não tenha dúvida que esse estudo é obrigatório para entender como funciona a linguagem.&lt;/p&gt;

&lt;h2 id=&quot;tipos-de-dados&quot;&gt;Tipos de dados&lt;/h2&gt;

&lt;p&gt;No ruby não existem tipos primitivos, todos os tipos são classes&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Object é a classe mãe de todas as outras classes em Ruby&lt;/li&gt;
  &lt;li&gt;Numeric é uma classe abstrata que representa números&lt;/li&gt;
  &lt;li&gt;Integer é uma classe que representa números inteiros&lt;/li&gt;
  &lt;li&gt;Fixnum representa números inteiros de precisão fixa&lt;/li&gt;
  &lt;li&gt;Bignum representa números inteiros de precisão infinita, dependente apenas da memória disponível&lt;/li&gt;
  &lt;li&gt;Float é uma classe que representa números de ponto flutuante(números reais)&lt;/li&gt;
  &lt;li&gt;String uma cadeia de caracteres. Pode ser delimitado por apóstrofes(‘)ou aspas(“). Tudo o que há entre apóstrofes literalmente, entres aspas o programador deve utilizar de símbolos para representar caracteres específicos, como C. Exemplo: ‘azul’, “a\nb\nc\”&lt;/li&gt;
  &lt;li&gt;Symbol é semelhante a uma string, mas dois símbolos iguais possuem o mesmo endereço de memória, sendo assim é ótimo para se utilizar como índice numa Hash. Porém, devido à sua natureza, o coletor de lixo de ruby não os elimina. É definido com um sinal de dois pontos (:), por exemplo, :none&lt;/li&gt;
  &lt;li&gt;Array são arrays dinâmicos, que podem ser usados para representar matrizes e vetores. É delimitado por colchetes([]) e cada valor é separado por vírgula. Exemplo: [4, ‘azul’, :termometro]&lt;/li&gt;
  &lt;li&gt;Hash representa um vetor associativo, e, assim como as Arrays, é dinâmica. É delimitada por chaves ({}), e o índice precede o valor com um sinal ‘=&amp;gt;’. Exemplo: {:controller =&amp;gt;’user’, :action = ‘index’}.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Qualquer objeto pode ser índice, mas os mais usados são as Strings e os Symbols&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Regex representa expressões regulares, delimitadas por //.
  Funciona de forma semelhante a Perl. Exemplo: 
  /a|ae/&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Esses são os tipos de dados usados na linguagem desde o início.&lt;/p&gt;

&lt;p&gt;Entenda isso e você vai entender a linguagem.&lt;/p&gt;

&lt;p&gt;Um dos conceitos básicos da linguagem é a declaração das variáveis, que basta uma associação entre um nome e um valor que é pronto é criada uma variável.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;no&quot;&gt;Ano&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Para você testar, vamos usar o interpretador do ruby que é o IRB(Interactive Ruby Shell).
Vá no seu terminal e digite irb, veja que ele vai abrir&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;╰─&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irb&lt;/span&gt;                       
&lt;span class=&quot;mf&quot;&gt;2.6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;001&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Um console que abre informando a versão do seu ruby e o número de vezes que ele foi usado.&lt;/p&gt;

&lt;p&gt;No primeiro exemplo declaramos uma variável do tipo inteiro que ela vai ser chamada de ano e atribuímos o valor 37 nela, mais como o interpretador sabe que ali tem uma variável do tipo inteiro.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ano&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ruby tem um intérpretador que infere o tipo de variável durante a execução do código.&lt;/p&gt;

&lt;p&gt;Uma forma interessante para você identificar o tipo da variável&lt;/p&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ano&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt; 
&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ano&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Você pediu para o puts mostrar o tipo da variável ano.
 Que o resultado vai ser :&lt;/p&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;╰─&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irb&lt;/span&gt;                          
&lt;span class=&quot;mf&quot;&gt;2.6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;001&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;001&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ano&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt; 
 &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt; 
&lt;span class=&quot;mf&quot;&gt;2.6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;002&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ano&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;Integer&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;nil&lt;/span&gt; 
&lt;span class=&quot;mf&quot;&gt;2.6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mo&quot;&gt;003&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Quando chamamos o &lt;strong&gt;.class&lt;/strong&gt; depois de qualquer variável ele trás o tipo de variável.&lt;/p&gt;

&lt;h2 id=&quot;tipagem&quot;&gt;Tipagem&lt;/h2&gt;

&lt;p&gt;Qual é a diferença entre tipagens;&lt;/p&gt;

&lt;h3 id=&quot;estática&quot;&gt;Estática&lt;/h3&gt;

&lt;p&gt;Tipagem estática é quando definimos explicitamente o tipo de variáveis de um software no código que na hora da compilação do código ele é conhecido e checado.&lt;/p&gt;

&lt;p&gt;Linguagem que usam tipagem estáticas 
Java, C#, F#, Kotlin, Go.&lt;/p&gt;

&lt;p&gt;Essa análise ajuda na chamada de segurança de tipos na utilização dos dados pelo programador.&lt;/p&gt;

&lt;h3 id=&quot;dinâmica&quot;&gt;Dinâmica&lt;/h3&gt;

&lt;p&gt;A tipagem dinâmica também é verificada mais de uma maneira diferente, ela verifica direto os tipos de dados.&lt;/p&gt;

&lt;p&gt;Linguagem que usam tipagens dinâmicas
Ruby, Python, Clojure, Elixir.&lt;/p&gt;

&lt;h3 id=&quot;forte&quot;&gt;Forte&lt;/h3&gt;
&lt;p&gt;A tipagem forte não realiza conversões automaticamente.&lt;/p&gt;

&lt;h3 id=&quot;fraca&quot;&gt;Fraca&lt;/h3&gt;

&lt;p&gt;A tipagem fraca, vem da característica da linguagem de realizar conversões automaticamente entre diferentes tipos de dados.&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Jan 2023 13:57:32 -0300</pubDate>
        <link>/o-basico-de-ruby</link>
        <guid isPermaLink="true">/o-basico-de-ruby</guid>
        
        <category>rails</category>
        
        <category>ruby</category>
        
        <category>linux</category>
        
        <category>metodos</category>
        
        
        <category>Rails</category>
        
        <category>Ruby</category>
        
        <category>Code</category>
        
      </item>
    
      <item>
        <title>MÉTODOS PARA TRATAR ARRAY</title>
        <description>&lt;p&gt;Recentemente me deparei em uma situação interessante, qual é o momento em que devemos usar &lt;strong&gt;map&lt;/strong&gt;, &lt;strong&gt;select&lt;/strong&gt; e o &lt;strong&gt;each&lt;/strong&gt;, normalmente eu uso o &lt;strong&gt;each&lt;/strong&gt; com frequência aí veio a dúvida em qual momento devemos usar os outros métodos e qual é a diferença entre eles?&lt;/p&gt;

&lt;p&gt;Dica: antes de procura em toda parte da web vá primeiro na documentação leia se não entendeu procure contexto diferentes de explicação, por que é importante você saber usar a documentação. Procurando na documentação você se depara com a seguinte situação;&lt;/p&gt;

&lt;h2 id=&quot;map&quot;&gt;MAP&lt;/h2&gt;

&lt;p&gt;O &lt;strong&gt;map&lt;/strong&gt; invoca o bloco fornecido uma vez para cada elemento de self. Criando um novo array contendo os valores retornados pelo bloco, se caso nenhum bloco for fornecido, um Enumerador será retornado&lt;/p&gt;

&lt;h4 id=&quot;detalhes-do-map&quot;&gt;Detalhes do &lt;strong&gt;map&lt;/strong&gt;:&lt;/h4&gt;
&lt;p&gt;O podemos usar ele com &lt;strong&gt;&lt;em&gt;arrays&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;hashes&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;ranges&lt;/em&gt;&lt;/strong&gt; o principal uso do &lt;strong&gt;&lt;em&gt;map&lt;/em&gt;&lt;/strong&gt; é transformar dados.&lt;/p&gt;

&lt;h4 id=&quot;por-exemplo&quot;&gt;por exemplo:&lt;/h4&gt;
&lt;p&gt;Dada uma matriz de strings, você pode passar por cima de cada string e tornar cada caractere maiúsculo&lt;/p&gt;

&lt;h4 id=&quot;sintaxe-do-map-no-ruby&quot;&gt;Sintaxe do map no Ruby&lt;/h4&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;upcase&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;collect&quot;&gt;Collect&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;collect&lt;/strong&gt; invoca o bloco fornecido uma vez para cada elemento de self, ele criar um novo array contendo os valores retornados pelo bloco, se não estiver nenhum bloco ele será retornado um Enumerador, no caso é a mesma coisa que o map.&lt;/p&gt;

&lt;h4 id=&quot;detalhes-do-collect&quot;&gt;Detalhes do collect&lt;/h4&gt;

&lt;p&gt;O collect() de enumerable é um método embutido em ruby que retorna um novo array com resultados da execução do bloco uma vez para cada elemento em enum O objeto é repetido todas as veses para cada enum, caso nenhum objeto seja fornecido, ele retorna nil para cada enum&lt;/p&gt;

&lt;h3 id=&quot;sintaxe&quot;&gt;Sintaxe:&lt;/h3&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bloquado&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Parâmetros: A função pega o objeto e o bloco que é para cada enum, também leva r1 e r2 que decide o número de elementos no enumerável retornado.&lt;/p&gt;

&lt;p&gt;valor do retorno: Retorna um novo array&lt;/p&gt;

&lt;p&gt;retorna o enumerador&lt;/p&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;enu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# [20, 30, 40, 50, 60]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;retorna&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;valor&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;nil&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;enu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# [nil, nil, nil, nil, nil]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;fonte-geeksforgeeks&quot;&gt;fonte: Geeksforgeeks&lt;/h5&gt;
&lt;h2 id=&quot;select&quot;&gt;Select&lt;/h2&gt;

&lt;p&gt;O &lt;strong&gt;select&lt;/strong&gt; funciona de duas maneiras únicas; Primeiro: pega o bloco para que possa ser usado como array#select Segundo: Modifica a instrução SELECT da consulta para que apenas determinados campos sejam recuperados.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;event?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# [2, 4]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Exemplo 2:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sx&quot;&gt;%w{ a b c d e f }&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/[aeiou]/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# [&quot;a&quot;, &quot;e&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;detalhes-do-select&quot;&gt;Detalhes do select&lt;/h4&gt;

&lt;p&gt;Select é um método de calsse array que retorna um novo array contendo todos os elementos do array para os quais o bloco dado retorna um valor verdadeiro.&lt;/p&gt;

&lt;p&gt;Sintaxe: array.select()&lt;/p&gt;

&lt;p&gt;Parâmentro: Matriz&lt;/p&gt;

&lt;p&gt;Retorno: Uma nova matriz contendo todos os elemetos da matriz para os quais o bloco fornecido retorna um valor verdadeiro.&lt;/p&gt;

&lt;h5 id=&quot;fonte-geeksforgeeks-1&quot;&gt;fonte: Geeksforgeeks&lt;/h5&gt;

&lt;p&gt;O each chama o bloco fornecido uma vez para cada elemento em self, passando esse elemento como um parâmetro, no caso ele retornar o próprio array, se caso nenhum bloco for fornecedor ele também traz um Enumerador.&lt;/p&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;--&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# a--b--c-- =&amp;gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Isso foi um resumo para entender melhor como tratar seus array usando métodos diferentes para situações diferentes.&lt;/p&gt;

&lt;h5 id=&quot;fontes-apidock&quot;&gt;Fontes: Apidock&lt;/h5&gt;
</description>
        <pubDate>Fri, 20 Jan 2023 12:33:12 -0300</pubDate>
        <link>/metodos-para-tratar-array</link>
        <guid isPermaLink="true">/metodos-para-tratar-array</guid>
        
        <category>rails</category>
        
        <category>ruby</category>
        
        <category>linux</category>
        
        <category>metodos</category>
        
        
        <category>Rails</category>
        
        <category>Ruby</category>
        
        <category>Code</category>
        
      </item>
    
  </channel>
</rss>
